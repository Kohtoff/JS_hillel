


/*              HOMEWORK                */

// function myBind(func, myThis, ...args) {
//     return function bound(...boundArgs) {
//         return func.apply(myThis, args, boundArgs);
//     };  
// }


    

// const obj = {
//     a: 2,
//     foo: function (...param) {
//         console.log(this, param);
//         console.log(this.a);
        
//     }
// };

// const baz = myBind(obj.foo, obj, 8, 9);
// console.log(baz());






/*              END OF HOMEWORK                */














/*              THEORY                  */


/*  this неявно дает нам ссылку обьекта
Это помогает нам сделать наш код более чистым и читаемы,
а так же повторно использовать его
Мы можем отойти от использования определенных параметров 
Наши функции будут понимать, основаяюсь на способе их вызова,
на какой контекст нужно ссылаться*/

/*this поможет нам работать с прототипным наследованием.
К примеру, возможность конкретных экземпляров знать контекст
своего вызова и иметь доступ к коллекциям целых методов */

/*this не указывает на функцию!!! 
В таком случае это вызывало бы рекурсию(когда функция ссылается
сама на себя)*/

/*this не ссылается на область видимости функции!!!
Тут и да, и нет одновременно. Технически контекст
выполнения имеет вид обьекта и у него есть различные свойства
для каждого определенного значения.
Но, опять же, технически this не указывает на обьект!!
и на область видимости!! 
Он указывает на контекст выполнения, но это не одно и то же ??????????????
Мы не имеем доступ к контексту выполнения наших функций,
что не дает нам возможности полноценно познакомиться с тем как это работает, 
а лишь концептуально расмотреть как это выглядит и как это воспринимается
интепретатором*/

/*Итого: this - это не ссылка на функцию 
и не ссылка на область видимости !!!!!!*/

/*Мы не знем на что будет указывать this до вызова функции. 
Именно по-этому его также называют контекстом вызова.*/

/*Когда функция вызывается создается КОНТЕКС ВЫЗОВА.
Он содержит информацию о том,
!!! Откуда функция была вызвана(Стек вызова)
!!! Каким способом функция была вызвана(с помощью круглых скобок,
                                        с помощью оператора new
                                        или специальных методов)
!!! Какие аргументы были переданы */

/*То есть контекст выполнения хранит в себе ссылку this,
ВСЕГДА указывает на обьект
(кроме одного случая, о котором поговорим через пару минут)*/

/*ПОКА МЫ НЕ УЗНАЕМ ГДЕ И КАК БЫЛА ВЫЗВАНА ФУНКЦИЯ 
МЫ НЕ СМОЖЕМ ОТВЕТИТЬ ЧЕМ ЯВЛЯЕТСЯ this */

/*НЕ ПУТАТЬ ОБЬЯВЛЕНИЕ И ВЫЗОВ ФУНКЦИИ!!! */

/*Стэк вызовов - структура, в которую попадает каждый вызов функций,
  которая должна нас привести к текущей точке исполнения кода*/

                            
                            /*ПРИМЕР*/

    // function baz(){
    //     console.log("baz");
    //     bar();
    //     console.log("end baz");
    // }

    // function bar(){
    //     console.log("bar");
    //     foo();
    //     console.log("end bar");
    // }

    // function foo(){
    //     console.log("foo");
    //     console.log("end foo");
    // }

    // baz();

    //result: baz -> bar -> foo -> end foo -> end bar -> end baz 

/*Каждый вызов функции создает специальный обьект -
 "Контекст выполнения". 
 Контекст выполнения попадает в стэк.
 Во время того как интерпретатор вызывает функцию baz() создается
 контекст выполнения, который попадает в стэк.
 Как только вызывается функция bar(), которая находится в baz()
 процедура повторяется(то есть
    снова создается новый контекст выполнения,
    который попадает в стэк вызовов).
 Теперь, управления передается от контекста выполнения baz() 
 контексту выполнения bar()
 В момент когда интерпретатор видит вызов другой функции, 
 он выходит из контекста первой функции и переходит 
 в контекст выполнения свежевызваной функции. */

/* Стэк работает по принципо LIFO*/

 /*
        Stack
 -------------------------
 | _____________________ |
 | |                   | |
 | |   function baz()  | |
 | |                   | |
 | |     (мы тут)      | |
 | _____________________ |
 | _____________________ |
 | |                   | |
 | |   function bar()  | |
 | |                   | |
 | _____________________ |
 | _____________________ |
 | |                   | |
 | |   function baz()  | |
 | |                   | |
 | _____________________ |
 -------------------------

 После того как мы закончили выполнения функции
 контекст вызова выходит из стэка. 
 Интепретатор возвращается к предыдущему контексту вызова
 В данном случае к bar()

        Stack
 -------------------------
 | _____________________ |
 | |                   | |
 | |   function bar()  | |
 | |                   | |
 | _____________________ |
 | _____________________ |
 | |                   | |
 | |   function baz()  | |
 | |                   | |
 | _____________________ |
 -------------------------

 
 */

 /*Очень важно найти настоящую точку вызова в нашем стэке вызовов,
 это единственная вещь,
 которая даст нам определить привязку this(контекста вызова) */

                    /*Как точка вызова определяет
                    на что будет указывать this?*/

/*1 ПРАВИЛО: Default this
    Имеет самый низкий приоритет
  */

    // function foo(){
    //     console.log(this);      //Указывает на глобальный обьект Window
    //     console.log(this.a);    // 42
    // }

    // var a = 42;
    // foo();                      // точка вызова 

    /*Что бы понять что применяется свзяка по умолчанию
     нужно найти точку вызова. 
     В данном случае foo() вызывается по прямой, необернутой ссылке
     на функцию. Мы просто обратились по ссылке(по имени)
     Так как неодно правило,
     которые мы рассмотрим дальше не применяется,
     применяется правило this по-умолчанию */

     /*!!! Однако, существует "Строгий режим кода", 
     котрый включается дерективой "use strict" */

    //  'use strict';

    //  function foo(){
    //     console.log(this);      
    //     console.log(this.a);    
    // }

    // var a = 42;
    // foo();     
    
    /*В данном случае нас ждет ошибка: 
        Cannot read property 'a' of undefined
    Так как у нас включен strict mode обьект Global не попадает
    под действие привязки по умолчанию. 
    В этом режиме this по-умолчанию устанавливается в undefined*/

    /*Это сделано для того что бы не было ситуации, когда мы
    неявным способом меняем что-либо 
    в глобальном обьекте */




    /*2 ПРАВИЛО: Owner object */
    /*Если у точки вызова есть обьект контекста(владеющий обьект),
    то контекстом вызова функции будет этот владеющий обьект*/


// 'use strict';

// function foo(){
//         console.log(this);      //указывает на обьект
//         console.log(this.a);    // указывает на свойство обьекта - 5
//     }
//     var a = 42;

//     const obj = {
//         a: 5, 
//         foo,
//     }

//  obj.foo();  // вот здесь предшествует обьектная ссылка на obj

 /*Внезависимости от того была ли функция foo() 
 изначально обьявлена в нашем обьекте
 или была добавлена ссылка(как в данном случае)
 ни в том, ни в другом случае функция обьекту не принадлежит
 или не соддержиться,
 Однако точка вызова использует обьект,
  что бы ссылаться внутри функции на сам обьект.
То есть наш обьект владеет или соержит ссылку на функцию
 в момент ее вызова */
 /*В момент когда вызывается функция ей предшествует
  обьектная ссылка на обьект. 
  Мы можем сказать, что когда вызывается метод, то this
  указывает на обьект до точки */

  /*То есть можно сказать, что obj является this 
  для вызова foo(), а this.a === obj.a */

//   'use strict';

// function foo(){
//         console.log(this);      
//         console.log(this.a);    // по-прежнему будет 5
//     }
//     var a = 42;

//     const obj = {
//         a: 5, 
//         foo,
//     }

//     const obj2 = {
//         a: 12,
//         obj,
//     }

//  obj2.obj.foo();

 /* В данном случае this.a === 5, так как нас интересует лишь
 тот обьект который является обьекотом до точки вызова функции */

 /*Существует также неявная потеря контекста вызова.
 */

//  function foo(){
//     console.log(this);      // global object Window
//     console.log(this.a);    // 42
// }
// var a = 42;

// const obj = {
//     a: 5, 
//     foo,
// }

// const baz = obj.foo;

// baz();

/*Произошла потеря контекста вызова.
В baz была записана ссылка, так как функция, на самом деле,
не принадлежит obj.
То есть запись 
(const baz = obj.foo;) === (baz = foo;)
Что означает, что, в данном случае, пытаясь вызвать метод обьекта
мы вызываем лишь функцию, не заходя в обьект*/
/*К тому же фактической точкой вызова будет baz, 
который в данный момент является прямым, непривязанным вызовом.
Таким образом сейчас применяется привязка по умолчанию(1ое правило
                                                        default this)  */

/*Еще один случай, когда мы можем потерять контекст вызова -
когда мы бередаем функцию в качестве аргумента */

// function foo(){
//     console.log(this);      //Виндоу
//     console.log(this.a);    // 42
// }

// var a = 42; 

// const obj = {
//     a:5,
//     foo,
// };

// function baz(fn){
//     fn();       // это не новый обьект
// };

// baz(obj.foo);

/*Мы опять сталкиваемся с первым правилом */
/*Когда мы передаем обьект в качестве аргумента нам важно
помнить, что мы по-прежнеум передаем на самом деле ссылку. */
/*К тому же функция не была вызвана как метод обьекта,
что привело бы нас ко второму правилу */
/*Передаваемый аргумент - это неяявное присвоение.
 Мы передаем функцию, то есть присваеваем ссылку на эту функцию */


 /* 3 ПРАВИЛО: Явная привязка контекста вызова(Binding)*/

 /*У каждой функции есть методы call & apply. 
 Первый параметра - обьект,
  который будет использлваться в качестве this*/
  
  
// function foo(param){
//     console.log(this, param);      
//     console.log(this.a);    
// }

// var a = 42; 

// const obj = {
//     a:5,
// };

// foo.call(obj, 42); // мы четко говорим, что this в функцие foo() - первый аргумент

/*apply принимает итерируемые обьекты в отличии от call */

  
// function foo(param, param1){
//     console.log(this, param, param1);      
//     console.log(this.a);    
// }

// var a = 42; 

// const obj = {
//     a:5,
// };

// foo.apply(obj, [1,2]);


/*Жесткая привязка*/

// function foo(param, param1){
//     console.log(this, param, param1);      
//     console.log(this.a);    
// }

// var a = 42; 

// const obj = {
//     a:5,
//     foo,
// };

// const baz = obj.foo.bind(obj,1,2); 

//  console.log(baz());

/*Bind возвращает новую функцию с уже привязанным контекстом.
Контекст мы изменить не можем. 
У функции, которую возвращает есть свойство name, которое
наследуется*/





/*4 ПРАВИЛО: new Binding 
    самый выскоий приоритет*/

/*Когда ф-ция вызывается с указанием оператора new(конструктор!!)
в этот момент выполняется */

// function foo(num){
//     // 1. a = {}
//     // 2 prototype
//     // 3 this = a
//     // 4 return this
//     this.a = num;
//     console.log(this);
// }

// const a = new foo(42); //object
// const b = new foo(5); //object

/*Созданный обьект связивается с прототипом.
Этот обьект становится this для нашей ф-ции*/
/*Вызов функции с new автоматически возвращает новый обьект */


/* !!!!!!!ИТОГ:
1й случай: Самый приоритетный с оператором new
            То есть this указывает на сконструированный обьект
2й случай: Функция вызвана с помощью call/apply/bind
            То есть this указывает на тот обьект, который мы
            передаем в качестве параметра контекста
            (!!Но, bind можно перебить только с помощью
            new!!)
3й случай: Функция вызвана как метод обьекта 
            То есть this является обьектом до точки
4й случай: this по-умолчанию*/


/*!!!!!ИСКЛЮЧЕНИЯ:
    Проигнорированный this: он приводит к методу по дефолту(
                            1ое правило)*/

// function foo(par,par1){
//     console.log(this, par, par1);  
//     console.log(this.a);          
// }

// foo.call(null);
// foo.apply(null);
// foo.bind(null);

/*  Лексический this: лямбда-функции не используют
                      правила описанные выше. Вместо этих правил
                      они используют привязку this из 
                      окружающих функций или глобальной области.
                      Это обусловлено тем, что у лямбда-функций
                      нет своего контекста вызова*/

// function foo(){
//     return () => {
//         console.log(this);
//     }   
// }

// const obj1 = {
//     a:2,
// };

// const obj2 = {
//     a:5,
// };

// const baz = foo.call(obj1); //arrow function потому что foo возвращает стрелочную функцию

// baz.call(obj2); //2, потому что контекст вызова будет взят из
                // лексического окружения, коим является
                // ф-ция foo(), контекст которой был привязан
                // во время вызова к obj1
/*Лексическая привязка стрелочной функции не может быть перекрыта ничем,
в том числе с помощью new. Потому что у лямбда-ф-ции нету возможности
вызвать деконструктор из-за отсутствия собственного this */